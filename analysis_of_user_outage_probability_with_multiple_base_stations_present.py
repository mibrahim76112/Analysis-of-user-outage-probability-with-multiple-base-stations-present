# -*- coding: utf-8 -*-
"""Analysis of user outage probability with multiple base stations present

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1girG1FvnFyDCOJhPtfuA-A55W-cPzKJC
"""

import numpy as np
import matplotlib.pyplot as plt
import random
from tqdm import tqdm

c = 3*pow(10,8);
  fc = 2.4*pow(10,9);
  a_L = 2;
  a_n = 3.3;
  x_uhf = 1;
  d = np.arange(0.01,50,0.5);
  pt = 30;
  u = 1;
  pr_los = [];
  pr_nlos = [];

def pathloss(d,a):
  y = c/fc;
  path_loss = 20*np.log10(4*np.pi/y)+10*a*np.log10(d)+x_uhf;
  path_loss = np.array(path_loss)

  return path_loss

def pr(pt,Loss,u):
  pr = pt - Loss  + 20*np.log10(u);
  return pr;

def randomly_split_data(d, thresh):
    random.shuffle(d)  # Shuffle the distance randomly

    n = int(len(d) * thresh)
    nlos_dist = d[:n]
    los_dist = d[n:]

    return los_dist, nlos_dist

path_loss = pathloss(d,a_L)

print(path_loss)

pathloss_los = pathloss(d,a_L)
  pathloss_nlos = pathloss(d,a_n)

  pr_los = pr(pt,pathloss_los,u)
  pr_nlos = pr(pt,pathloss_nlos,u)

#//////////////////////////////////////////////////////

#Plotting path losses
  plt.plot(d,pathloss_los, label = 'LOS');
  plt.plot(d,pathloss_nlos, label = 'N-LOS');
  plt.title('Path Loss')
  plt.ylabel('Path loss')
  plt.xlabel('Distance')
  plt.legend()
  plt.show()

#Plotting received power
  plt.plot(d,pr_los, label = 'LOS');
  plt.plot(d,pr_nlos, label = 'N-LOS');
  plt.title('Received power')
  plt.ylabel('Received power')
  plt.xlabel('Distance')
  plt.legend()
  plt.show()

area = [-250, 250] # area of the simulation m^2
n_user = 100 # number of users
n_bs = 1 # number of base stations

#Base stration at the origin
bs = np.array([[100, 100],[-150,0],[100,-150]])
users = np.array([])

for _ in range(n_user):
    x = np.random.uniform(area[0], area[1])
    y = np.random.uniform(area[0], area[1])
    users = np.append(users, np.array([x, y]))

users = users.reshape(n_user, 2) # reshape the array to 100 x 2

# Plot the network
plt.scatter(bs[:, 0], bs[:, 1], label = "Base station")
plt.scatter(users[:, 0], users[:, 1], label = "Users")
plt.legend()
plt.show()

print(bs)

def euclidean_distance(x1, y1, x2, y2):
    distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return distance

distance_mat = []
for i in range(len(bs)):
    distances = []
    for user in users:
        distance = euclidean_distance(bs[i][0], bs[i][1], user[0], user[1])
        distances.append(distance)
    distance_mat.append(distances)

distance_mat = np.array(distance_mat)
print("Distance matrix: ", distance_mat)

thresh = 0.1
los_dist = []
nlos_dist = []
for i in range(len(bs)):
    split_data = randomly_split_data(distance_mat[i], thresh)
    los_dist.append(split_data[0])
    nlos_dist.append(split_data[1])

los_dist = np.array(los_dist)
nlos_dist = np.array(nlos_dist)

np.shape(nlos_dist)

# LOS path losses
path_loss_los = []
for k in range(len(los_dist)):
    path_loss_k = []
    for d in los_dist[k]:
        path_loss_k.append(pathloss(d, a_L))
    path_loss_los.append(path_loss_k)

path_loss_los = np.array(path_loss_los)

# N-LOS path losses
path_loss_nlos = []
for d in nlos_dist:
    path_loss_nlos.append(pathloss(d, a_n))
path_loss_nlos = np.array(path_loss_nlos)

# Concatenation
concatenated_losses = np.concatenate((path_loss_los, path_loss_nlos), axis=1)
print("Concatenated Path Losses: ")
print(concatenated_losses)
for i in range(len(bs)):
  random.shuffle(concatenated_losses[i])

# Find minimum values for each index
f_p_loss = np.min(concatenated_losses, axis=0)
print(f_p_loss)

N = 100
mu, sigma = 0, np.sqrt(0.5)
pt = 50# transmitted power in dbs
Pr = np.array([])

# Rayleigh fading channel
X = np.random.normal(mu, sigma, N)
Y = np.random.normal(mu, sigma, N)
g = np.sqrt(X**2 + Y**2)
mag_g = np.sqrt(np.mean(g**2))
Pr = pt - f_p_loss + 10*np.log10(mag_g**2) # received power
random.shuffle(Pr)
print('Received power', + Pr)

B = 20*10**6;
NF = 10;
noise = -174+10*np.log10(B) + NF;

snr_mat = []
rate_mat = np.array([])
snr_mat = Pr- noise;
print('SNR', + snr_mat)
rate_mat = (B/n_user)*np.log2(1 + 10**(snr_mat/10))
print('\n\nRate', + rate_mat)

coverage_prob = 1 - np.sum(rate_mat < 3.5e6) / n_user
print("Coverage probability: ", coverage_prob)

"""# **Monte Carlos Simulation**

---



---


"""

area = [-250, 250] # area of the simulation m^2
n_user = 100 # number of users
n_bs = 3 # number of base stations
Ns = 1;
mu, sigma = 0, np.sqrt(0.5)
iterations = 100 # number of iterations
thresh = 0.1;
a_L = 2;
a_n = 3.3;
outage_prob_mat = np.array([])

for _ in tqdm(list(range(iterations))):

    def pathloss(d,a):
      y = c/fc;
      path_loss = 20*np.log10(4*np.pi/y)+10*a*np.log10(d)+x_uhf;
      path_loss = np.array(path_loss)

      return path_loss

    #Base stration at the origin
    bs = np.array([[100, 100],[-150,0],[100,-150]])
    users = np.array([])

    for _ in range(n_user):
        x = np.random.uniform(area[0], area[1])
        y = np.random.uniform(area[0], area[1])
        users = np.append(users, np.array([x, y]))

    users = users.reshape(n_user, 2) # reshape the array to 100 x 2

    distance_mat = []
    for i in range(len(bs)):
        distances = []
        for user in users:
            distance = euclidean_distance(bs[i][0], bs[i][1], user[0], user[1])
            distances.append(distance)
        distance_mat.append(distances)

    distance_mat = np.array(distance_mat)

    los_dist = []
    nlos_dist = []
    for i in range(len(bs)):
        split_data = randomly_split_data(distance_mat[i], thresh)
        los_dist.append(split_data[0])
        nlos_dist.append(split_data[1])

    los_dist = np.array(los_dist)
    nlos_dist = np.array(nlos_dist)

    # LOS path losses
    path_loss_los = []
    for k in range(len(los_dist)):
        path_loss_k = []
        for d in los_dist[k]:
            path_loss_k.append(pathloss(d, a_L))
        path_loss_los.append(path_loss_k)

    path_loss_los = np.array(path_loss_los)

    # N-LOS path losses
    path_loss_nlos = []
    for d in nlos_dist:
        path_loss_nlos.append(pathloss(d, a_n))
    path_loss_nlos = np.array(path_loss_nlos)

    # Concatenation
    concatenated_losses = np.concatenate((path_loss_los, path_loss_nlos), axis=1)
    for i in range(len(bs)):
      random.shuffle(concatenated_losses[i])

    f_p_loss = np.min(concatenated_losses, axis=0)



    Pr = np.array([])
    X = np.random.normal(mu, sigma, Ns)
    Y = np.random.normal(mu, sigma, Ns)
    g = np.sqrt(X**2 + Y**2)
    mag_g = np.sqrt(np.mean(g**2))

    Pr = pt - f_p_loss + 10*np.log10(mag_g**2) # received power
    noise = -174+10*np.log10(B) + NF;
    snr_mat = []
    rate_mat = np.array([])
    snr_mat = Pr - noise;
    print('SNR', + snr_mat)
    rate_mat = (B/n_user)*np.log2(1 + 10**(snr_mat/10))
    print('\n\nRate', + rate_mat)

    outage_prob_mat = np.append(outage_prob_mat, np.sum(rate_mat < 2) / n_user)

outage_prob = np.average(outage_prob_mat)

def total_coverage_probability(rate_mat, threshold_rate):
    coverage_probability = np.sum(rate_mat > threshold_rate) / n_user
    return coverage_probability

print("Total Coverage probability: ", total_coverage_probability(rate_mat, 3e6))

thresholds = np.arange(2e6, 0.5e7, 20)
coverage_prob = np.array([])

for threshold in thresholds:
    coverage_prob = np.append(coverage_prob, total_coverage_probability(rate_mat, threshold))

plt.plot(thresholds, coverage_prob)
plt.xlabel("Threshold rate")
plt.ylabel("Coverage probability")
plt.grid()
plt.show()